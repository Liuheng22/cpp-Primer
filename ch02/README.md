## 练习2.1
*   整形数据使用中一般用int类型，short一般是2字节，太短，不太够。而long一般和int一样4字节，不常用。若是int范围太小，选择long long类型
*   float是单精度浮点型，double是双精度浮点型，但是使用上却与他们精度和表达范围关系不大。因为，现在计算机字长和double的长度一样，所以使用double和float类型是一样的，所以现在float不常用，大情况下用double。

## 练习2.2
*  利率一般是小数，所以用double双精度浮点数。本金一般是正整数，选用unsigned int,付款为本金和利率的乘积相关，所以用double双精度浮点数。
  
## 练习2.3
*  (1) 32 ， 第二个结果为负，取模得到 4294967264
*  (2) 32 ，-32 ， 0 ， 0
  
## 练习2.5
*  (a) 第一个为字面量为'a'的字符，第二个为宽字符，第三个为为'a'的字符串，第四为内容为宽字符的字符串。
*  (b) 第一个为10的十进制整数字面量，第二个为为10的无符号十进制整数，第三个为     为10的十进制的长整型整数。第四个为字面量为10的十进制无符号长整型整数。第五个为字面量为10的八进制表示的整数，第六个为字面量为10的十六进制表示的整数。
*  (c) 第一个为3.14的带符号的double型浮点数。第二个为字面量为3.14的带符号的float型浮点数，第三个为字面量为3.14的long double型浮点数。
*  (d) 第一个为字面量为10的十进制int整数，第二个为字面量为10的十进制无符号int整数，第三个为字面量为10的有符号double型浮点数，第四个为字面量为0.1的double型有符号浮点数。
          
## 练习2.6
*  第一组是10进制表示的字面量，mouth = 9，day = 7;而第二组用的是8进制表示的，mouth = 09，day = 07，因为八进制没有9所以会无效。
  
## 练习2.7
* (a) 该行表示"Who goes with Fergus?空行"
* (b) 31.4的long double浮点数
* (c) 无效，因为f只能用于浮点型。
* (d) 3.14的long double浮点数
 
## 练习2.8
> 请利用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。
```c++
#include<iostream>
using namespace std;

int main()
{
	cout << "2M\n" << endl;
	cout << "2\tM\n" << endl;
	return 0;
}
```
## 练习2.9
*  （a）应该先定义再使用。
>  int input_value = 0;cin >> input_value;
*  （b）列表初始化，丢失信息，崩溃。
>  double i = {3.14};
*  （c）在为salary赋值的时候，wage未定义。
>  double  wage = 9999.99;double salary = wage;
*  （d）不会崩溃，但是会丢失信息，i = 3。
>  double i = 3.14;
## 练习2.10
*  global_str 初始化一个空串。
*  global_int 全局变量，默认初始化为0。
*  local_int 未初始化，变量未定义成功（随机初始化）。
*  local_str 初始化一个空串，与类相关。
## 练习2.11
*  (a) 定义，不仅声明了变量类型还有初始化，其实是定义。
*  (b) 定义，默认初始化。
*  (c) 声明，并没有显示初始化。
## 练习2.12
*  (a)double是双精度浮点型的关键字。
*  (b)合法
*  (c)下划线，而不是横线。
*  (d)不能出现两次下划线。
*  (e)合法.
## 练习2.13
*  j = 100;i的是全局作用于，函数里面还有一个局部作用域，而且在j前。
## 练习2.14
*  for中的i为局部作用域。输出100 45
## 练习2.15
*  (a)合法，定义一个int变量，但是初始化会丢失数据。
*  (b)不合法，引用不能用字面量，只能用变量绑定初始化。
*  (c)合法。
*  (d)不合法，因为没有初始化。
## 练习2.16
* (a)合法，相当于给d赋了3.14159
* (b)合法，相当于把i的值赋给d，d = 0；
* (c)合法，相当于把d的值赋给i，d的值为0；
* (d)合法，相当于把d的值赋给i。
## 练习2.17
```cpp
#include<iostream>
using namespace std;
int main()
{
	int i,&ri = i;
	i = 5;ri = 10;
	cout << i << " " << ri << endl; 
	return 0;
} 
```
* 输出为10 10；
## 练习2.19
* 指针和引用都是间接访问对象的方式。但是引用不是对象，它只是和对象绑定，相当于给对象一个别名，然后，访问引用相当于访问原来对象，所以它本身不能改变，只能改变和他绑定的对象的值。所以引用必须在定义的时候初始化。而指针是一个对象，它里面存的是他指向对象的地址，可以通过解引用符访问指针所指对象，从而改变他里面存的值，而且由于它本身是一个变量，所以可以改变它里面的值，相当于，将指针指向另外的对象。
## 练习2.20
* int i = 42 给i初始化为42；int *pl = &i;相当于定义一个指针，并且初始化指向i;*pl =*pl*(*pl),相当于给pl指向的对象赋值，即i赋i*i得值
## 练习2.21
* (a)非法，因为给一个指向double的指针附一个整形的地址，会出错。(b)非法，因为，不能给指针变量赋一个非地址的值。缺一个取址符。
## 练习2.22
* 1.如果p内存的地址为0则bool值为false，否则bool值为1。2.如果p指向的int对象的值为0，则bool值为false，否则为1。
## 练习2.23
* 看指针能不能访问，若能，则合法。
## 练习2.24
* p为任意类型的指针，因此，他什么类型的指针都能存，而lp为长整形指针，他不能存int对象的地址，类型不对。
## 练习2.25
* (a)ip 是int型指针，i为int型变量，r为i的引用。(b)i是int型变量，ip为指向空地址的指针变量。(c)ip为int型指针,ip2为int型变量。
## 练习2.26
* (a)不合法，因为const定义了就不能更改，所以必修初始化。(b)合法。(c)合法。(d)不合法，cnt可以加1，但是，sz不能改变。
## 练习2.27
* (a)不合法，r为引用，因此右边必须为对象，而0为字面量。(b)合法，前提是i2是int型变量。(c)非法，r是引用，不能和字面量关联。(d)合法，前提是i2必须为int型变量。(e)合法，前提是i2为int型变量。(f)不合法，引用必须初始化。(g)合法。
## 练习2.28
* (a)不合法，cp为常量指针，所以必须初始化。(b)不合法，p2为常量指针，必须初始化。(c)合法。(d)不合法，未初始化。(e)合法。
## 练习2.29
* (a)合法。(b）合法。(c)不合法。ic为常量，而p1为int指针。(d)不合法。p3为常量指针，不能赋值。(e)
不合法 ，p2为常量指针，不能赋值。(f)不合法，ic为常量，不能改变。
## 练习2.30
* v2为顶层const,v1为顶层const；p1为都不是，r1也都不是。p2是底层const，p3既为底层又为顶层const。
## 练习2.31
* 第一句合法，这里v2为顶层变量，因此不改变，相当于将将v2的值拷贝给v1；第二句不合法，p2为底层const，const不能拷贝给非const变量。第三句合法。第四句不合法，p3为底层const也为顶层const，不能拷贝给int。
## 练习2.32
* 不合法，应该改为Nullptr。
## 练习2.33
* a运行成功；b运行成功；c运行成功；d非法；e非法;g非法。
## 练习2.35
* j为int整形；k为常整数引用；p非法；j2位整形常量；k2位整数常量引用。
## 练习2.36
* c类型为int；d为int引用，绑定在a上；c为4；d=4;
## 练习2.37
* c为int类型，3；d为int型引用，与a绑定，3。
