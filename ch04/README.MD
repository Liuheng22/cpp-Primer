## 练习4.1
> 根据分配律和结合律可以得出，105。
## 练习4.5
* (a).-86 (b).-18 (c).0 (d).-2.
## 练习4.6
* n%2;若结果为0，则为偶数，否则为基数。
## 练习4.7
* 溢出是指，值大于变量类型所表达的范围。
## 练习4.8
* 逻辑与和逻辑或求值是先对左运算对象求值，再对右运算对象求值，因为有短路的设置，提高效率。相等性运算未定义先计算那个对象的值。
## 练习4.9
* 先的得到cp的值，地址不为0，则为真。然后再计算*cp的值，为真。
## 练习4.11
```cpp
   if(a>b&&b>c&&c>d);
```
## 练习4.12
* j与k比较，若k大为1，否则为0；i在与这个结果的bool量比较，若一样则为0，不同则为1。
## 练习4.13
* （a）i为3，d为3.0。（b）d为3.5，i为3。
## 练习4.14
* 上面的表达式执行的时候会出错，因为，42是整形字面量，不能当左值，会出错。下面的表达式，赋值运算符，返回的是左侧值的结果，为42，所以一直为真。
## 练习4.15
* 主要是ival = pi出了问题，因为类型不能转换。
```cpp
   dval = ival = 0;
   pi = 0;
```
## 练习4.16
* （a）由于赋值运算符优先级特别低，所以，这个表达式，会先计算函数返回值是否等于0，然后再赋值给p。运行没有问题，效果有，但是不好理解。
```cpp
   if((p = getPtr()) != 0);
```
* （b）将1024赋值给i,永远为真。无意义
```cpp
   if(i==1024)
```   
## 练习4.17
* 前置递增运算符是先运算，再得到结果，对象的值是加了之后的，是左值。
* 后置递增运算符是先得到对象的值再运算，得到的是原先副本的值，是右值。
## 练习4.18
* 用前置运算符，返回的是加1后的指针，所以，输出的值会缺少首元素，然后会输出尾元素后的一个元素，溢出非法。
## 练习4.19
* （a）指针不为0的情况下，且指针所指int对象的值不为0.且指针向前移动一位。
* （b）ival不为零，且ival+1不为零。
* （c）不正确，这里对于ival有两次求值，而且对于ival有修改，且求值顺序不固定。不用递增符号，用加1.
## 练习4.20
* （a）合法，迭代器保存副本作为返回值，迭代器本身指向下一个位置。副本指向的对象解引用，返回对象内的值。
* （b）不合法，先将迭代器解引用，得到字符串。将字符保存副本返回。再将字符串递增，没有重载这个操作，错误。
* （c）不合法，点运算符的优先级高于解引用运算符，而iter为迭代器，不能得到成员的对象，错误。
* （d）合法，会得到iter这个迭代器所指的字符串里的成员的对象，是个函数，是左值。
* （e）不合法，字符串不能++。
* （f）合法，会先将迭代器保存副本，再将迭代器递增保存，副本对应的成员empty函数返回，是个左值。
## 练习4.23
* 算术运算符优先级高于条件运算符，所以会先计算加法。
```cpp
   string p1 = s + (s[s.size() - 1] == 's'?"" : "s");
```
## 练习4.24
* cout << (grade > 90 ) ? "high pass" : (grade < 60 )? "fail":"pass";
* 相当于
* cout << ((grade > 90 ) ? "high pass" : (grade < 60 )) ? "fail":"pass";
* 当grade大于90时，得到high pass,为真，因此输出fail，结果错误。
## 练习4.25
* 7232，先自动转成int型。
## 练习4.26
* 会不同机器中int的长度不停，可能小于27位，造成错误。
## 练习4.27
* （a）3 （b）7 （c）1 （d）1
## 练习4.29
* 10
* 未定义，由于地址长度和int长度不一定。
## 练习4.30
* （a）sizeof （x）+y （b）sizeof(p->men[1])（c）sizeof(a)<b（d）sizeof(f()).
## 练习4.31
* 因为，后置运算符，会产生一个副本，占用内存。使用后置运算符，不需要修改代码。
## 练习4.32
* 对于有5个元素的int数组，遍历数组元素。
## 练习4.33
* someValue值为true，x，y加1。否则x,y减1。
## 练习4.34
* （a）float到bool （b）ival先从int转float,与fval相加转为double赋值给dval （c）ival与cval相乘，cval转为int型，在与dval相加，转为double。
## 练习4.35
